[ { "title": "Redux Toolkit Quick Start", "url": "/posts/redux-toolkit-quick-start/", "categories": "Frontend", "tags": "Redux", "date": "2022-05-23 23:00:00 +0900", "snippet": "Redux Toolkit Quick StartUsage Summary​Install Redux Toolkit and React-ReduxAdd the Redux Toolkit and React-Redux packages to your projectnpm install @reduxjs/toolkit react-reduxCreate a Redux StoreCreate a file named src/app/store.js. Import the configureStore API from Redux Toolkit. We’ll start by creating an empty Redux store, and exporting it:// app/store.jsimport { configureStore } from \"@reduxjs/toolkit\";export const store = configureStore({ reducer: {},});This creates a Redux store, and also automatically configure the Redux DevTools extension so that you can inspect the store while developing.Provide the Redux Store to ReactOnce the store is created, we can make it available to our React components by putting a React-Redux &lt;Provider&gt; around our application in src/index.js. Import the Redux store we just created, put a &lt;Provider&gt; around your &lt;App&gt;, and pass the store as a prop.// index.jsimport React from \"react\";import ReactDOM from \"react-dom\";import \"./index.css\";import App from \"./App\";import { store } from \"./app/store\";import { Provider } from \"react-redux\";ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(\"root\"));Create a Redux State SliceAdd a new file named src/features/counter/counterSlice.js. In that file, import the createSlice API from Redux Toolkit.Creating a slice requires a string name to identify the slice, an initial state value, and one or more reducer functions to define how the state can be updated. Once a slice is created, we can export the generated Redux action creators and the reducer function for the whole slice.Redux requires that we write all state updates immutably, by making copies of data and updating the copies. However, Redux Toolkit’s createSlice and createReducer APIs use Immer inside to allow us to write “mutating” update logic that becomes correct immutable updates.// features/counter/counterSlice.jsimport { createSlice } from \"@reduxjs/toolkit\";const initialState = { value: 0,};export const counterSlice = createSlice({ name: \"counter\", initialState, reducers: { increment: (state) =&gt; { state.value += 1; }, decrement: (state) =&gt; { state.value -= 1; }, incrementByAmount: (state, action) =&gt; { state.value += action.payload; }, },});export const { increment, decrement, incrementByAmount } = counterSlice.actions;export default counterSlice.reducer;Add Slice Reducers to the StoreNext, we need to import the reducer function from the counter slice and add it to our store. By defining a field inside the reducer parameter, we tell the store to use this slice reducer function to handle all updates to that state.// app/store.jsimport { configureStore } from \"@reduxjs/toolkit\";import counterReducer from \"../features/counter/counterSlice\";export const store = configureStore({ reducer: { counter: counterReducer, },});Use Redux State and Actions in React ComponentsNow we can use the React-Redux hooks to let React components interact with the Redux store. We can read data from the store with useSelector, and dispatch actions using useDispatch. Create a src/features/counter/Counter.js file with a &lt;Counter&gt; component inside, then import that component into App.js and render it inside of &lt;App&gt;.import React from \"react\";import { useSelector, useDispatch } from \"react-redux\";import { decrement, increment } from \"./counterSlice\";export function Counter() { const count = useSelector((state) =&gt; state.counter.value); const dispatch = useDispatch(); return ( &lt;div&gt; &lt;div&gt; &lt;button aria-label=\"Increment value\" onClick={() =&gt; dispatch(increment())} &gt; Increment &lt;/button&gt; &lt;span&gt;{count}&lt;/span&gt; &lt;button aria-label=\"Decrement value\" onClick={() =&gt; dispatch(decrement())} &gt; Decrement &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; );}Now, any time you click the “Increment” and “Decrement” buttons. The corresponding Redux action will be dispatched to the store The counter slice reducer will see the actions and update its state The &lt;Counter&gt; component will see the new state value from the store and re-render itself with the new dataSUMMARY Create a Redux store with configureStore configureStore accepts a reducer function as a named argument configureStore automatically sets up the store with good default settings Provide the Redux store to the React application components Put a React-Redux &lt;Provider&gt; component around your &lt;App /&gt; Pass the Redux store as &lt;Provider store={store}&gt; Create a Redux “slice” reducer with createSlice Call createSlice with a string name, an initial state, and named reducer functions Reducer functions may “mutate” the state using Immer Export the generated slice reducer and action creators Use the React-Redux useSelector/useDispatch hooks in React components Read data from the store with the useSelector hook Get the dispatch function with the useDispatch hook, and dispatch actions as needed " }, { "title": "Thinking In Redux", "url": "/posts/thinking-in-redux/", "categories": "Frontend", "tags": "Redux", "date": "2022-05-21 23:00:00 +0900", "snippet": "Three PrinciplesSingle source of truthThe global state of your application is stored in an object tree within a single storeState is read-onlyThe only way to change the state is to emit an action, an object describing what happeChanges are made with pure functionsTo specify how the state tree is transformed by actions, you write pure reducers.GlossaryActionAn action is a plain object that representan intention to change the state. Actions are the only way to get data into the storeReducerA reducer (also called a reducing function) is a function that accepts an accumulation and value and returns a new accumulation. They are used to reduce a collection of values down to single value.Dispatching FunctionA dispatching function (or simply dispatch function) is a function that accepts an action or an async action. it then may or may not dispatch one or more actions to the store.The base dispatch function always synchronously sends an action to the store’s reducer, along with the previous state returned by the store, to calculate a new state. It expects actions to be plain objects ready to be consumed by the reducer.Action CreatorAn action creator is, quite simply, a function that creates an action.StoreA store is an object that holds the application’s state tree. There should only be a single store in a Redux app, as the composition happens on the reducer level" }, { "title": "Redux Essentials", "url": "/posts/redux-essentials/", "categories": "Frontend", "tags": "Redux", "date": "2022-05-19 23:00:00 +0900", "snippet": "Redux Overview and ConceptsWhat is Redux?Redux is pattern and library for managing and updating application state, using events called “actions”. It serves as a centralized store for state that needs to be used across your entire application, with rules ensuring that the state can only be updated in a predictable fashion.Why Should I Use Redux?Redux helps you manage “global” state - state that is needed across many parts of your applicationThe patterns and tools provided by Redux make it easier to understand when, where, why, and how the state in your application is being updated, and how your application logic will behave when those changes occur. Redux guides you towards writing code that is predictable and testable, which helps give you confidence that your application will work as expected.When Should I Use Redux? You have large amounts of application state that are needed in many places in the app The app state is updated frequently over time The logic to update that state may be complex The app has a medium or large-sized codebase, and might be worked on by many peopleTerminologyActionsAn action is a plain JavaScript object that has a type filed. You can think of an action as an event that describes something that happened in the application.The type field should be a string that gives this action a descriptive name. The first part is the feature or category that this action belongs to, and the second part is the specific thing that happened.An action object can have other fileds with additional information about what happened. By convention, we put that information in a field called payload.Action CreatorsAn action creator is a function that creates and returns an action object.ReducersA reducer is a function that receives the current state and an action object, decides how to update the state if necessary, and returns the new state. You can think of a reducer as an event listener which handles events based on the received action type. They should only calculate the new state value based on the state and action arguments They are not allowed to modify the existing state. Instead, they must make immutable updates, by copying the existing state and making changes to the copied values. They must not do any asynchronous logic, calculate random values, or cause other “side effects”StoreThe current Reudx application state lives in an object called the store.DispatchThe only way to update the state is to call dispatch and pass in an action object.SelectorsSelectors are functions that know how to extract specific pieces of information from store state value." } ]
